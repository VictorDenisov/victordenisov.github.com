---
layout: post
title: "Make Software Engineering Again"
date: 2018-08-31 01:32:37 -0700
comments: true
categories: 
---

I've repeatedly came across various blog posts on the Internet that software
engineering has nothing to do with engineering. They liked to give examples
how accountable and responsible real engineers are and how reckless are software
engineers.

I personally came to a conclusion that even if software is an engineering discipline
not everyone practices it as such.

Let's discuss what issues are there in software engineering.

After 10 years in the industry I'm disappointed.
You don't gain experience. You keep debugging things again and again with no chance
not to encounter this issue later.

Software systems are the most complicated systems we've ever dealt with in the
history of mankind.

The industry is not set up to make conscious decisions. We have many products with
similar characteristics and community keeps creating new versions of the same
thing introducing the same problems. Why do we have 10 relational databases.

- Fashion
- Market opportunity

Let's start picking our tools and libraries carefully without creating
redundancy and splitting it apart as necessary.

Software developers can decide to use a library without fully understanding
the implications of using this library. It's unheard of in any other engineering
discipline to use a material with unknown parameters. However because of
complexity of software and constant expansion of the horizon of available
programs and libraries programmers are always forced to act in the environment
of some uncertainty. Every time writing a new piece of software are like
sending a moon probe and arguing whether the Moon is solid.

Scientific approach to developing libraries.

How does science work? We add layers of knowledge on top of existing layer
we restructure existing knowledge, but we never recreate existing concepts.
Nobody has several implementations of Newtonian physics where gravity works
slightly different in different implementations. Software engineering
should employ similar approach.

Instead of building several databases or even building one totally configurable
database we need to decompose our database into smaller blocks that allow us to build any of them at our discretion any time and the way that is the most convenient for us.
That can be embedded in any system.

Reusable implementations of existing algorithms that can be assembled into anything we
want like Lego bricks.

And we need to have one language that is truly universal. We don't have such a
language yet.
This language should produce truly composable primitives.
So far it looks like Haskell is the one.
Though I believe it's still in research stage.

Open source is a solution for good tools.

Suckless tools - cut the complexity.

Awk and sed.

What is wrong with software engineering

